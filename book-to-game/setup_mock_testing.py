#!/usr/bin/env python3
"""
Quick setup script for book-to-game mock testing
"""
import os
import sys
import subprocess
import time
from pathlib import Path

def check_dependencies():
    """Check if required packages are installed"""
    print("üîç Checking dependencies...")
    
    required_packages = [
        "fastapi", "uvicorn", "requests", "python-dotenv", 
        "pydantic", "openai", "asyncio"
    ]
    
    missing_packages = []
    
    for package in required_packages:
        try:
            __import__(package.replace("-", "_"))
            print(f"   ‚úÖ {package}")
        except ImportError:
            print(f"   ‚ùå {package} (missing)")
            missing_packages.append(package)
    
    if missing_packages:
        print(f"\nüì¶ Installing missing packages: {', '.join(missing_packages)}")
        try:
            subprocess.check_call([
                sys.executable, "-m", "pip", "install"
            ] + missing_packages)
            print("‚úÖ Dependencies installed successfully!")
        except subprocess.CalledProcessError:
            print("‚ùå Failed to install dependencies")
            return False
    else:
        print("‚úÖ All dependencies are installed!")
    
    return True

def setup_environment():
    """Setup environment files"""
    print("\nüîß Setting up environment...")
    
    # Create .env file for mock testing
    env_content = """# Mock environment for book-to-game testing
OPENAI_API_KEY=mock-api-key
OPENAI_MODEL=gpt-4
OPENAI_BASE_URL=https://api.openai.com/v1
MOCK_MODE=true

# Database (not used in mock mode)
DATABASE_URL=sqlite:///./test.db

# Logging
LOG_LEVEL=INFO
"""
    
    env_path = Path(".env")
    if not env_path.exists():
        env_path.write_text(env_content)
        print("‚úÖ Created .env file")
    else:
        print("‚úÖ .env file already exists")
    
    # Check directory structure
    required_dirs = [
        "src/api",
        "src/agents", 
        "src/services",
        "src/models",
        "src/utils"
    ]
    
    for dir_path in required_dirs:
        Path(dir_path).mkdir(parents=True, exist_ok=True)
        
        # Ensure __init__.py exists
        init_file = Path(dir_path) / "__init__.py"
        if not init_file.exists():
            init_file.touch()
    
    print("‚úÖ Directory structure verified")

def check_mock_client():
    """Check if mock OpenAI client exists"""
    print("\nü§ñ Checking mock OpenAI client...")
    
    mock_client_path = Path("src/utils/mock_openai.py")
    if not mock_client_path.exists():
        print("‚ö†Ô∏è Mock OpenAI client not found. Creating one...")
        
        mock_client_content = '''"""
Mock OpenAI client for testing without API calls
"""
import asyncio
from typing import Dict, Any, List
import random
import time

class MockChatCompletion:
    def __init__(self, content: str):
        self.choices = [MockChoice(content)]

class MockChoice:
    def __init__(self, content: str):
        self.message = MockMessage(content)

class MockMessage:
    def __init__(self, content: str):
        self.content = content

class MockChat:
    def __init__(self):
        self.completions = MockCompletions()

class MockCompletions:
    async def create(self, **kwargs) -> MockChatCompletion:
        """Mock chat completion with realistic delay"""
        # Simulate API delay
        await asyncio.sleep(random.uniform(0.5, 2.0))
        
        # Generate mock response based on context
        messages = kwargs.get('messages', [])
        if messages:
            last_message = messages[-1].get('content', '')
            if 'Unity' in last_message or 'C#' in last_message:
                content = self._generate_unity_code()
            elif 'game design' in last_message.lower():
                content = self._generate_game_design()
            elif 'asset' in last_message.lower():
                content = self._generate_asset_spec()
            elif 'quality' in last_message.lower() or 'review' in last_message.lower():
                content = self._generate_qa_review()
            else:
                content = self._generate_generic_response()
        else:
            content = self._generate_generic_response()
        
        return MockChatCompletion(content)
    
    def _generate_unity_code(self) -> str:
        return """using UnityEngine;
using System.Collections;
using System.Collections.Generic;

/// <summary>
/// Scene controller for interactive educational content
/// Generated by BookToGame AI system
/// </summary>
public class SceneController : MonoBehaviour
{
    [Header("Scene Configuration")]
    public string sceneTitle = "Educational Scene";
    public List<Character> characters = new List<Character>();
    public Environment environment;
    
    [Header("Interactive Elements")]
    public List<InteractiveObject> interactables = new List<InteractiveObject>();
    public DialogueManager dialogueManager;
    
    void Start()
    {
        InitializeScene();
        SetupCharacters();
        ConfigureEnvironment();
    }
    
    void InitializeScene()
    {
        Debug.Log($"Initializing scene: {sceneTitle}");
        // Scene initialization logic here
    }
    
    void SetupCharacters()
    {
        foreach (var character in characters)
        {
            character.Initialize();
        }
    }
    
    void ConfigureEnvironment()
    {
        if (environment != null)
        {
            environment.ApplySettings();
        }
    }
    
    public void OnInteractionTriggered(InteractiveObject obj)
    {
        // Handle interactive object interactions
        StartCoroutine(HandleInteraction(obj));
    }
    
    private IEnumerator HandleInteraction(InteractiveObject obj)
    {
        yield return obj.ExecuteInteraction();
    }
}"""
    
    def _generate_game_design(self) -> str:
        return """{
    "game_mechanics": [
        "Point and click interaction",
        "Dialogue trees with educational choices",
        "Mini-game integration",
        "Progress tracking system"
    ],
    "learning_objectives": [
        "Understand core concepts through interaction",
        "Apply knowledge in game scenarios",
        "Develop problem-solving skills"
    ],
    "ar_features": [
        "3D character visualization",
        "Interactive object placement",
        "Gesture-based controls",
        "Real-world overlay integration"
    ],
    "user_interface": {
        "main_menu": "Scene selection with progress indicators",
        "in_game_ui": "Minimalist overlay with context-sensitive controls",
        "feedback_system": "Visual and audio cues for learning progress"
    },
    "assessment_integration": {
        "formative": "Real-time feedback during interactions",
        "summative": "End-of-scene knowledge check",
        "adaptive": "Difficulty adjustment based on performance"
    }
}"""
    
    def _generate_asset_spec(self) -> str:
        return """{
    "visual_assets": {
        "characters": [
            {
                "name": "Main Character",
                "style": "Stylized 3D",
                "animations": ["idle", "walk", "talk", "gesture"],
                "textures": "High-quality PBR materials"
            }
        ],
        "environments": [
            {
                "name": "Scene Environment",
                "lighting": "Dynamic with educational mood",
                "props": "Interactive objects with highlight system",
                "optimization": "Mobile-friendly LOD system"
            }
        ]
    },
    "audio_assets": {
        "narration": "Professional voice acting with emotional range",
        "sound_effects": "Educational feedback sounds",
        "background_music": "Adaptive scoring based on scene mood"
    },
    "interactive_elements": [
        "Touch-responsive objects",
        "Drag-and-drop interfaces", 
        "Gesture recognition zones",
        "AR placement markers"
    ]
}"""
    
    def _generate_qa_review(self) -> str:
        return """{
    "overall_score": 85,
    "educational_value": {
        "score": 90,
        "comments": "Excellent integration of learning objectives with interactive elements"
    },
    "technical_quality": {
        "score": 85,
        "comments": "Well-structured Unity code following best practices"
    },
    "user_experience": {
        "score": 80,
        "comments": "Intuitive interface design with clear feedback mechanisms"
    },
    "accessibility": {
        "score": 85,
        "comments": "Good support for different learning styles and abilities"
    },
    "recommendations": [
        "Add more visual feedback for user actions",
        "Include difficulty scaling options",
        "Enhance AR interaction responsiveness"
    ],
    "approved": true
}"""
    
    def _generate_generic_response(self) -> str:
        return "This is a mock response from the AI system. In production, this would contain detailed, context-aware content generated by the actual AI model."

class MockOpenAIClient:
    """Mock OpenAI client for testing"""
    
    def __init__(self):
        self.chat = MockChat()
        print("ü§ñ Mock OpenAI client initialized")
'''
        
        mock_client_path.parent.mkdir(parents=True, exist_ok=True)
        mock_client_path.write_text(mock_client_content)
        print("‚úÖ Mock OpenAI client created")
    else:
        print("‚úÖ Mock OpenAI client exists")

def run_quick_test():
    """Run a quick test to verify everything works"""
    print("\nüß™ Running quick verification test...")
    
    try:
        # Test direct service import
        sys.path.insert(0, os.getcwd())
        from src.services.book_to_game_service import BookToGameService
        
        print("‚úÖ Service import successful")
        
        # Test mock initialization
        service = BookToGameService("mock-api-key", "gpt-4")
        print(f"‚úÖ Service initialized (mock mode: {service.coordinator.unity_agent.is_mock_mode})")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Quick test failed: {e}")
        import traceback
        traceback.print_exc()
        return False

def main():
    """Main setup function"""
    print("üöÄ BOOK-TO-GAME MOCK TESTING SETUP")
    print("="*50)
    
    # Check if we're in the right directory
    if not os.path.exists("src"):
        print("‚ùå Error: This doesn't appear to be the book-to-game directory")
        print("üí° Make sure you're in the NarrativeMorph/book-to-game folder")
        sys.exit(1)
    
    success = True
    
    # Step 1: Dependencies
    if not check_dependencies():
        success = False
    
    # Step 2: Environment
    setup_environment()
    
    # Step 3: Mock client
    check_mock_client()
    
    # Step 4: Quick test
    if not run_quick_test():
        success = False
    
    # Summary
    print("\n" + "="*50)
    if success:
        print("üéâ SETUP COMPLETE!")
        print("‚úÖ Ready for mock testing!")
        print("\nNext steps:")
        print("1. python test_complete_mock_system.py  # Complete system test")
        print("2. python start_mock_server.py         # Start API server")
        print("3. python test_scenarios.py            # Test different scenarios")
    else:
        print("‚ö†Ô∏è Setup completed with some issues")
        print("Check the errors above and try running the tests anyway")

if __name__ == "__main__":
    main()
